---
title: "klee_current"
author: "Carmen Ebel"
date: "4/18/2021"
output: html_document
---


# Data Prep
## Read in Data
```{r, echo=FALSE, include=FALSE}
## Load Packages, Read in Data ##
## set working directory
setwd("~/Repositories/klee-stability")

## Load packages
library(tidyverse)
library(lubridate)
library(codyn)
library(tsvr)
library(forcats)
library(knitr)
library(ggpubr)
library(data.table)
library(segmented)
library(breakpoint)
## source cleaned data
source("klee_data_cleaning_current.R")
source("precipitation_data_cleaning.R")
```


# Calculations
## Calculate Stability & Variance
``` {r,  echo=FALSE}
## Calculate Community Stability ##
commstab <- community_stability(klee_long, 
                                time.var = "Date_numeric", 
                                abundance.var = "Pin_Hits", 
                                replicate.var = "Unique_ID")

## join with treatment info & calculate CV
stability <- left_join(commstab, treats, by = "Unique_ID") %>% #join community stability with treatment info
  mutate(CV = 1/stability) #calculate the CV by taking the inverse of stability

## create a dataframe with mean & standard error of stability & CV by treatment
mean_stability <- stability %>%
  group_by(TREATMENT) %>%
  summarize(mean_st = mean(stability), SEst = calcSE(stability), mean_cv = mean(CV), SECV = calcSE(CV))

## Calculate Variance
## calculate the variance of each plot over time
v <- klee_long %>%
  group_by(TREATMENT, Unique_ID) %>%
  summarise(variance = var(Pin_Hits))

pinhits <- meantotcov %>%
  group_by(TREATMENT, Unique_ID) %>%
  summarize(pinhits = mean(Mean_TotCov))


variance <- left_join(v, pinhits, by = c("TREATMENT", "Unique_ID"))

meanvar <- variance %>%
  group_by(TREATMENT) %>%
  summarize(meanvar = mean(variance),
            SEvar = calcSE(variance), 
            meanbio = mean(pinhits), 
            SEbio = mean(pinhits))

## reorder treatments to match grazing pressure.
mean_stability$TREATMENT <- as.factor(mean_stability$TREATMENT) #change treatment to factor
mean_stability$TREATMENT <- factor(mean_stability$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))

meanvar$TREATMENT <- as.factor(meanvar$TREATMENT) #change treatment to factor
meanvar$TREATMENT <- factor(meanvar$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))

variance$TREATMENT <- as.factor(variance$TREATMENT) #change treatment to factor
variance$TREATMENT <- factor(variance$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))

rm(list = c("v", "commstab"))
```


## Calculate Stability over a Moving Window ##
``` {r, echo = FALSE}
## create function
movingwindow_func <- function(input_data, timestep, ...) { ## function inputs = data frame and number of time steps
  
  n_samples <- length(unique(input_data$Date_final)) ## number of sampling points
  n_windows <- n_samples - timestep + 1 ## how many windows to iterate over 
  movingwindow <- data.frame(matrix(ncol=3,nrow=(n_windows*length(unique(input_data$Unique_ID))))) ## create empty dataframe to contain output ## dimensions = # cols (3) x (uniqueID x timesteps)
  colnames(movingwindow) <- c("Unique_ID", "stability", "timestep")
  sample_points <- sort(unique(input_data$Date_numeric)) ## create ordered list of sample points
  
  n_plots <- length(unique(input_data$Unique_ID)) ## number of unique plots
  
  for (i in 1:n_windows){
    
    temp_samplepts <- sample_points[i:(i+timestep-1)] ## create a vector of sample points for each iteration
    
    temp <- input_data %>%
      filter(Date_numeric %in% temp_samplepts) ## filter the correct sample points from input data to run through the community stability function
    
    temp_commstab <- community_stability(temp,  ## run the community stability function from codyn
                                time.var = "Date_numeric", 
                                abundance.var = "Pin_Hits", 
                                replicate.var = "Unique_ID")
    temp_commstab$timestep <- i ## create a column for timestep in the temporary data frame
    
    movingwindow[((i-1)*n_plots + 1):(i*n_plots),] <- temp_commstab ## add stability calculations for one iteration to the moving window data frame
    ## ((i-1)*n_plots + 1):(i*n_plots) -> where to put each iteration of the loop
    
  }
  
  return(movingwindow) ## retrieve data frame at the end
  
}

## Use moving window function to calculate stability with ONLY June sampling points
annual_stab3 <- movingwindow_func(input_data = annual_all, timestep = 3) %>%
  mutate(window_size = 3)
annual_stab5 <- movingwindow_func(input_data = annual_all, timestep = 5) %>%
  mutate(window_size = 5)
annual_stab7 <- movingwindow_func(input_data = annual_all, timestep = 7) %>%
  mutate(window_size = 7)
annual_stab10 <- movingwindow_func(input_data = annual_all, timestep = 10) %>%
  mutate(window_size = 10)

ann3_5 <- rbind(annual_stab3, annual_stab5)
ann3_5_7 <- rbind(ann3_5, annual_stab7)

stability_mw <- rbind(ann3_5_7, annual_stab10)

stab_mw_tx <- left_join(stability_mw, treats, by="Unique_ID") %>%
  group_by(TREATMENT, timestep, window_size) %>%
  summarize(mean_stability = mean(stability), SE = calcSE(stability))

stab_mw_tx$TREATMENT <- as.factor(stab_mw_tx$TREATMENT) #change treatment to factor
stab_mw_tx$TREATMENT <- factor(stab_mw_tx$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))

rm(list = c("annual_stab3", "annual_stab5", "annual_stab7", "annual_stab10", "ann3_5", "ann3_5_7"))

```


## Synchrony

### Calculate Synchrony Metrics
```{r,  echo=FALSE}
## Calculate Loreau synchrony metric
loreau_synchrony <- synchrony(
  annual_all,
  time.var = "Date_numeric",
  species.var = "SPECIES",
  abundance.var = "Pin_Hits",
  metric = "Loreau",
  replicate.var = "Unique_ID"
)
colnames(loreau_synchrony) <- c("Unique_ID", "loreau_synchrony") #rename columns

## Calculate Gross synchrony metric
gross_synchrony <- synchrony(
  annual_all,
  time.var = "Date_numeric",
  species.var = "SPECIES",
  abundance.var = "Pin_Hits",
  replicate.var = "Unique_ID",
  metric="Gross")
colnames(gross_synchrony) <- c("Unique_ID", "gross_synchrony") #rename columns

## join two synchrony metrics into one data frame
synchrony <- left_join(loreau_synchrony, gross_synchrony, by = "Unique_ID") 

## join with treatment data
synchrony_tx <- inner_join(synchrony, treats, by = "Unique_ID")
synchrony_stability <- left_join(synchrony, stability, by = "Unique_ID")

## calculate mean & SE of metrics to get ready for graphing
mean_synchrony <- left_join(synchrony, treats, by = "Unique_ID") %>%
  pivot_longer(cols = loreau_synchrony:gross_synchrony, names_to = "Metric_Name", values_to = "Synchrony") %>% #pivot to long format
  group_by(TREATMENT, Metric_Name) %>%
  summarise(mean_value = mean(Synchrony), SE_value = calcSE(Synchrony))

## reorder treatments to match grazing pressure.
mean_synchrony$TREATMENT <- as.factor(mean_synchrony$TREATMENT) #change treatment to factor
mean_synchrony$TREATMENT <- factor(mean_synchrony$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))

## join synchrony & stability data frames to get ready for graphing
syn_stab <- inner_join(mean_synchrony, mean_stability, by = "TREATMENT")

rm(list = c("loreau_synchrony", "gross_synchrony", "synchrony_tx", "synchrony"))
```


### Synchrony over a Moving Window
```{r, echo=FALSE}
## create function
synchronymw_func <- function(input_data, timestep, ...) { ## function inputs = data frame and number of time steps
  
  n_samples <- length(unique(input_data$Date_final)) ## number of sampling points
  n_windows <- n_samples - timestep + 1 ## how many windows to iterate over 
  mw_synchrony <- data.frame(matrix(ncol=4,nrow=(n_windows*length(unique(input_data$Unique_ID))))) ## create empty dataframe to contain output ## dimensions = # cols (3) x (uniqueID x timesteps)
  colnames(mw_synchrony) <- c("Unique_ID", "loreau_synchrony", "timestep", "gross_synchrony")
  
  sample_points <- sort(unique(input_data$Date_numeric)) ## create ordered list of sample points
  
  n_plots <- length(unique(input_data$Unique_ID)) ## number of unique plots
  
  for (k in 1:n_windows){
    
    temp_samplepts <- sample_points[k:(k+timestep-1)] ## create a vector of sample points for each iteration
    
    temp <- input_data %>%
      filter(Date_numeric %in% temp_samplepts) ## filter the correct sample points from input data to run through the community stability function
    
    
    ## Calculate Loreau synchrony metric
    temp_lsyn <- synchrony(
      temp,
      time.var = "Date_numeric",
      species.var = "SPECIES",
      abundance.var = "Pin_Hits",
      metric = "Loreau",
      replicate.var = "Unique_ID"
      )
    
    colnames(temp_lsyn) <- c("Unique_ID", "loreau_synchrony") #rename columns
    temp_lsyn$timestep <- k ## create a column for timestep in the temporary data frame

  ## Calculate Gross synchrony metric
    temp_gsyn <- synchrony(
      temp,
      time.var = "Date_numeric",
      species.var = "SPECIES",
      abundance.var = "Pin_Hits",
      replicate.var = "Unique_ID",
      metric="Gross")
    
    colnames(temp_gsyn) <- c("Unique_ID", "gross_synchrony") #rename columns
    temp_gsyn$timestep <- k ## create a column for timestep in the temporary data frame
    
    ## join synchrony dataframes together
    tempsynch <- left_join(temp_lsyn, temp_gsyn, by= c("Unique_ID", "timestep"))
    
    mw_synchrony[((k-1)*n_plots + 1):(k*n_plots),] <- tempsynch ## add synchrony calculations for one iteration to the moving window data frame
    ## ((i-1)*n_plots + 1):(i*n_plots) -> where to put each iteration of the loop
    
  }
  
  return(mw_synchrony) ## retrieve data frame at the end
  
}


synchrony4 <- synchronymw_func(input_data = annual_all, timestep = 4)  %>%
  mutate(window_size = 4)
synchrony5 <- synchronymw_func(input_data= annual_all, timestep = 5)  %>%
  mutate(window_size = 5)
synchrony7 <- synchronymw_func(input_data = annual_all, timestep = 7)  %>%
  mutate(window_size = 7)
synchrony10 <- synchronymw_func(input_data = annual_all, timestep = 10)  %>%
  mutate(window_size = 10)

syn45 <- rbind(synchrony4, synchrony5)
syn457 <- rbind(syn45, synchrony7)
synchrony_mw <- rbind(syn457, synchrony10)

syn_mw_tx <- left_join(synchrony_mw, treats, by="Unique_ID") %>%
  group_by(TREATMENT, timestep, window_size) %>%
  summarize(meanloreau = mean(loreau_synchrony), SEloreau = calcSE(loreau_synchrony), meangross = mean(gross_synchrony), SEgross=calcSE(gross_synchrony))

syn_mw_tx$TREATMENT <- as.factor(syn_mw_tx$TREATMENT) #change treatment to factor
syn_mw_tx$TREATMENT <- factor(syn_mw_tx$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))

rm(list = c("syn45", "syn457", "synchrony4", "synchrony5", "synchrony7", "synchrony10"))

```

## Dominance
### Calculate Berger-Parker Dominance
```{r, echo=FALSE}
## Calculate Berger-Parker Dominance ##
#BP dominance: d = Nmax/N (relative abundance of most dominant species)
BP_dom <- klee_long %>%
  group_by(TREATMENT, Unique_ID, Date_final) %>% #group by treatment, plot, and date
  mutate(rank = rank(Pin_Hits, na.last = NA, ties.method = "average")) %>% #rank species in order of abundance
  mutate(tot_abund = sum(Pin_Hits)) %>% #calculate total abundance
  filter(rank == max(rank)) %>% #only include most abundant species in each plot
  summarise(BP_dominance = Pin_Hits/tot_abund) %>% #calculate Berger-Parker dominance index
  group_by(TREATMENT, Date_final) %>% #group by treatment and date
  summarise(mean_dom = mean(BP_dominance), SEdom = calcSE(BP_dominance)) #calculate mean and SE for each treatment at each date

BP_dom2 <- klee_long %>%
  group_by(TREATMENT, Unique_ID, Date_final) %>% #group by treatment, plot, and date
  mutate(rank = rank(Pin_Hits, na.last = NA, ties.method = "average")) %>% #rank species in order of abundance
  mutate(tot_abund = sum(Pin_Hits)) %>% #calculate total abundance
  filter(rank == max(rank)) %>% #only include most abundant species in each plot
  summarise(BP_dominance = Pin_Hits/tot_abund) %>% #calculate Berger-Parker dominance index
  group_by(TREATMENT, Unique_ID, Date_final) %>% #group by treatment and date
  summarise(mean_dom = mean(BP_dominance), SEdom = calcSE(BP_dominance))

## calculate the mean dominance index by treatment
avg_BPdom <- BP_dom %>%
  group_by(TREATMENT) %>% #group by treatment
  summarise(avg_dom = mean(mean_dom), SE = calcSE(mean_dom)) #take mean across time for each treatment

dominance <- BP_dom2 %>%
  group_by(Unique_ID) %>%
  summarize(dominance = mean(mean_dom))

dominance <- left_join(dominance, treats, by = "Unique_ID")
dominance <- left_join(dominance, stability, by = c("Unique_ID", "BLOCK", "TREATMENT"))


#reorder treatments to match grazing pressure.
BP_dom$TREATMENT <- as.factor(BP_dom$TREATMENT) #change treatment to factor
BP_dom$TREATMENT <- factor(BP_dom$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))
avg_BPdom$TREATMENT <- as.factor(avg_BPdom$TREATMENT) #change treatment to factor
avg_BPdom$TREATMENT <- factor(avg_BPdom$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))

## join stability & dominance data frames
dom_stab <- inner_join(mean_stability, avg_BPdom, by = "TREATMENT")

rm(BP_dom2)
```


### Calculate Dominance over a Moving Window

```{r, echo=FALSE}

dominancemw_func <- function(input_data, timestep, ...) { ## function inputs = data frame and number of time steps
  
  n_samples <- length(unique(input_data$Date_final)) ## number of sampling points
  n_windows <- n_samples - timestep + 1 ## how many windows to iterate over 
  movingwindow <- data.frame(matrix(ncol=4,nrow=(n_windows*length(unique(input_data$TREATMENT))))) ## create empty dataframe to contain output ## dimensions = # cols (3) x (uniqueID x timesteps)
  colnames(movingwindow) <- c("TREATMENT", "timestep", "mean_dominance", "SE_dominance")
  sample_points <- sort(unique(input_data$Date_numeric)) ## create ordered list of sample points
  
  n_plots <- length(unique(input_data$Unique_ID)) ## number of unique plots
  n_trt <- length(unique(input_data$TREATMENT))
  
  for (i in 1:n_windows){
    
    temp_samplepts <- sample_points[i:(i+timestep-1)] ## create a vector of sample points for each iteration
    
    temp <- input_data %>%
      filter(Date_numeric %in% temp_samplepts) ## filter the correct sample points from input data to run through the community stability function
    
    temp_dom <- temp %>%
      group_by(TREATMENT, Unique_ID, Date_final) %>%
      mutate(rank = rank(Pin_Hits, na.last = NA, ties.method = "average")) %>% #rank species in order of abundance
      mutate(tot_abund = sum(Pin_Hits)) %>% #calculate total abundance
      filter(rank == max(rank)) %>% #only include most abundant species in each plot
      summarise(BP_dominance = Pin_Hits/tot_abund) #calculate Berger-Parker dominance index
      
    temp_dom$timestep <- i ## create a column for timestep in the temporary data frame
    
    mean_dom <- temp_dom %>%
      group_by(TREATMENT, timestep) %>%
      summarise(BP_dom = mean(BP_dominance), SEBP = calcSE(BP_dominance))
    
    movingwindow[((i-1)*n_trt + 1):(i*n_trt),] <- mean_dom ## add stability calculations for one iteration to the moving window data frame
    ## ((i-1)*n_plots + 1):(i*n_plots) -> where to put each iteration of the loop
    
  }
  
  return(movingwindow) ## retrieve data frame at the end
  
}

dom3 <- dominancemw_func(input_data = annual_all, timestep = 3) %>%
  mutate(window_size = 3)
dom5 <- dominancemw_func(input_data = annual_all, timestep = 5) %>%
  mutate(window_size = 5)
dom7 <- dominancemw_func(input_data = annual_all, timestep = 7) %>%
  mutate(window_size = 7)
dom10 <- dominancemw_func(input_data = annual_all, timestep = 10) %>%
  mutate(window_size = 10)

dom35 <- rbind(dom3, dom5)
dom357 <- rbind(dom35, dom7)
dominance_mw <- rbind(dom357, dom10)

dominance_mw$TREATMENT <- as.factor(dominance_mw$TREATMENT) #change treatment to factor
dominance_mw$TREATMENT <- factor(dominance_mw$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))

rm(list = c("dom35", "dom357", "dom3", "dom5", "dom7", "dom10"))

```


### Calculate Species Rank and Stability
```{r, echo=FALSE}
## rank species in order of abundance with 1 being most abundant.
rankneg <- klee_long %>%
  group_by(TREATMENT, Unique_ID, Date_final) %>%
  mutate(rank = rank(-Pin_Hits, na.last = NA, ties.method = "average")) %>% #rank species in order of abundance
  mutate(tot_abund = sum(Pin_Hits)) #calculate total abundance


trt <- unique(klee_long$TREATMENT) ## create vector of treatments for loop to iterate over

dominant.sp <- data.frame(SPECIES=NA, stability=NA, rank=NA, SE=NA, TREATMENT=NA) ## create empty dataframe to contain output. Don't know exact number of rows, will need to just make empty columns and bind in loop

domsp <- data.frame(TREATMENT=NA, Date_final=NA, SPECIES=NA,mean=NA, SE=NA)

## create for loop
for (j in 1:length(trt)) {
  
  ## pull out the jth sampling unit from the data
  temp <- rankneg %>%
    filter(TREATMENT == trt[j])
  
  ## filter to contain only the top 2 most abundant species at any point in the time series
  ranktemp <- temp %>%
    filter(rank < 3)
  
  ## make a unique vector of top 2 abundant sp at any point
  tempsp <- unique(ranktemp$SPECIES)
  
  ## filter by top 2 species
  tempspdf <- temp %>%
    filter(SPECIES %in% tempsp) %>%
    group_by(TREATMENT, Date_final, SPECIES) %>%
    summarize(mean=mean(Pin_Hits), SE=calcSE(Pin_Hits))
  
  ## save this to a new data frame
  domsp <- rbind(tempspdf, domsp)

  
  ## filter entire time series by top 2 species to get their full time series. Calculate stability
  tempstab <- temp %>%
    filter(SPECIES %in% tempsp) %>%
    group_by(BLOCK, SPECIES) %>%
    summarise(temp_mean = mean(Pin_Hits), sdhits = sd(Pin_Hits), sp_stability = temp_mean/sdhits, meanrank = mean(rank)) %>%
    ungroup() %>%
    group_by(SPECIES) %>%
    summarise(stability = mean(sp_stability), rank=mean(meanrank), SE = calcSE(sp_stability)) %>%
    mutate(TREATMENT = trt[j])
  
  ## save stability calculations in new dataframe
  dominant.sp <- rbind(tempstab, dominant.sp)
  
}

## Change mean rank to integer
dominant.sp <- dominant.sp %>%
  mutate(rank_int = ifelse(rank <= 1.49, 1, 
                           ifelse(rank > 1.49 & rank <=2.49, 2,  
                                  ifelse(rank > 2.49 & rank <=3.49, 3,
                                         ifelse(rank >3.49 & rank <=4.49, 4,
                                                ifelse(rank >4.49 & rank <=5.49, 5,
                                                       ifelse(rank > 5.49 & rank <=6.49, 6,
                                                              ifelse(rank >6.49 & rank <=7.49, 7,
                                                                     ifelse(rank>7.49 & rank <=8.49, 8,
                                                                            ifelse(rank>8.49 & rank <=9.49,9,
                                                                                   ifelse(rank>9.49 & rank <=10.49, 10, 
                                                                                          ifelse(rank>10.49 & rank <=11.49, 11,
                                                                                                 ifelse(rank >11.49 & rank <=12.49, 12, 
                                                                                                        ifelse(rank >12.49 & rank <= 13.49, 13,
                                                                                                               ifelse(rank >13.49 & rank <=14.49, 14, 15)))))))))))))))

```


### Calculate Species Richness
```{r, echo=FALSE}
## Calculate total species richness across the time series 
#may need to eventually use presence-absence data (accounts for a lot more rare species)
totalrich <- klee_long %>%
  group_by(TREATMENT, Unique_ID) %>%
  select(Unique_ID, SPECIES, TREATMENT) %>%
  unique() %>%
  summarise(totalrich = n()) %>%
  group_by(TREATMENT) %>%
  summarise(meantotrich = mean(totalrich), totrichSE = calcSE(totalrich))

## Calculate Richness at each Time step 
#calculate richness by grouping by unique ID and date and counting # of observations.
ann_rich <- klee_long %>%
  group_by(Unique_ID, Date_final) %>%
  summarise(richness = n())

rich_time <- klee_long %>%
  group_by(TREATMENT, Unique_ID, Date_final) %>%
  summarise(richness = n()) %>%
  group_by(TREATMENT, Date_final) %>%
  summarise(meanrich = mean(richness), SErich = calcSE(richness))

## Mean Annual Richness
#calculate the average species richness for each plot then each treatment. Average by plot first then by treatment
richness <- left_join(ann_rich, treats, by="Unique_ID") %>%
  group_by(TREATMENT, Unique_ID) %>%
  summarise(meanSR_plot = mean(richness))

richness <- left_join(richness, stability, by = c("Unique_ID", "TREATMENT"))

avg_rich <- left_join(ann_rich, treats, by="Unique_ID") %>%
  group_by(TREATMENT, Unique_ID) %>%
  summarise(meanSR_plot = mean(richness)) %>%
  group_by(TREATMENT) %>%
  summarise(meanSR_tx = mean(meanSR_plot), SESR_tx = calcSE(meanSR_plot))

## Join richness and stability data
rtemp <- left_join(avg_rich, mean_stability, by = "TREATMENT")
richstab <- left_join(rtemp, totalrich, by="TREATMENT")

#reorder treatments to match grazing pressure.
richstab$TREATMENT <- as.factor(richstab$TREATMENT) #change treatment to factor
richstab$TREATMENT <- factor(richstab$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))

rich_time$TREATMENT <- as.factor(rich_time$TREATMENT) #change treatment to factor
rich_time$TREATMENT <- factor(rich_time$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))

rm(list = c("rtemp", "avg_rich", "ann_rich", "totalrich"))
```


# Significance Testing
## ANOVAs and Linear Models
```{r}
## is stability significantly different by grazing treatment?
## use stability data frame
fitstability <- aov(stability~TREATMENT, data = stability)
summary(fitstability)

TukeyHSD(fitstability)
## O is significantly different from C, MW, MWC, WC
## WC-W are marginally significantly different
## other treatments not significantly different from each other


fitvariance <- aov(variance~TREATMENT, data=variance)
summary(fitvariance)

TukeyHSD(fitvariance)


fitpinhits <- aov(pinhits~TREATMENT, data=pinhits)
summary(fitpinhits)
TukeyHSD(fitpinhits)

## is the dominance index significantly different by grazing treatment?
fitdom <- aov(dominance~TREATMENT, data=dominance)
summary(fitdom)
## treatment not a significant effect


## is richness significantly different by grazing treatment?
fitrich <- aov(meanSR_plot~TREATMENT, data = richness)
summary(fitrich)
## treatment not a significant effect


## is synchrony significantly different by grazing treatment?
fitlsyn <- aov(loreau_synchrony~TREATMENT, data = synchrony_stability)
summary(fitlsyn)
TukeyHSD(fitlsyn)
## O is significantly different from C, MW, MWC, WC
## W-MWC significant
## WC-W are significantly different
## other treatments not significantly different from each other

fitgsyn <- aov(gross_synchrony~TREATMENT, data = synchrony_stability)
summary(fitgsyn)
TukeyHSD(fitgsyn)
## MWC-O marginally significant
## WC-0 significant
## nothing else is significantly different


## Does synchrony predict stability?
fitstablsyn <- lm(stability~loreau_synchrony, data = synchrony_stability)
summary(fitstablsyn)
## significant

fitstabgsyn <- lm(stability~gross_synchrony, data = synchrony_stability)
summary(fitstabgsyn)


fitstabdom <- lm(stability~dominance, data = dominance)
summary(fitstabdom)
## marginally significant

fitstabrich <- lm(stability~meanSR_plot, data = richness)
summary(fitstabrich)
## marginally significant
```

## Correlation Analysis for Moving Windows
```{r}

## correlation test
stab_dom_mw <- left_join(stab_mw_tx, dominance_mw, by = c("TREATMENT", "timestep", "window_size"))
stabdO_mw_3 <- stab_dom_mw %>%
  filter(TREATMENT == "0", window_size == "3")

cor.test(stabdO_mw_3$mean_dominance, stabdO_mw_3$mean_stability,
         alternative = "two.sided",
         method = "pearson")
## no correlation

## does synchrony correlate with stability changes over time?
stab_syn_mw <- left_join(stab_mw_tx, syn_mw_tx, by = c("TREATMENT", "timestep", "window_size")) %>%
  filter(window_size > 3)

stabsynO_mw_5 <- stab_syn_mw %>%
  filter(TREATMENT == "0", window_size == "5")

cor.test(stabsynO_mw_5$meanloreau, stabsynO_mw_5$mean_stability,
         alternative = "two.sided",
         method = "pearson")

stabsynO_mw_7 <- stab_syn_mw %>%
  filter(TREATMENT == "0", window_size == "7")

cor.test(stabsynO_mw_7$meanloreau, stabsynO_mw_7$mean_stability,
         alternative = "two.sided",
         method = "pearson")

stabsynO_mw_10 <- stab_syn_mw %>%
  filter(TREATMENT == "0", window_size == "10")

cor.test(stabsynO_mw_10$meanloreau, stabsynO_mw_10$mean_stability,
         alternative = "two.sided",
         method = "pearson")
## unsure if I am interpreting this correctly, but: 
  ## strong negative correlations between loreau synchrony and stability for all window sizes



## should probably do breakpoint analysis in a for-loop to avoid repeating lines of code...




## use package breakpoint to check for breakpoints in the moving window analysis
## data frame must be single column
O_bp7 <- dominance_mw %>%
  filter(TREATMENT == "0", window_size == "7") %>%
  select(mean_dominance)
CE.Normal.Mean(O_bp7, penalty = "AIC")
## no breakpoints are estimated

O_bp3 <- dominance_mw %>%
  filter(TREATMENT == "0", window_size == "3") %>%
  select(mean_dominance)
CE.Normal.Mean(O_bp3, penalty = "AIC")
## 1 breakpoint at 6


O_bpstab5 <- stab_mw_tx %>%
  filter(TREATMENT == "0", window_size == "5") %>%
  ungroup() %>%
  select(mean_stability)

CE.Normal.Mean(O_bpstab5, penalty = "AIC")
## no breakpoints are estimated

O_bpstab3 <- stab_mw_tx %>%
  filter(TREATMENT == "0", window_size == "3") %>%
  ungroup() %>%
  select(mean_stability)

CE.Normal.Mean(O_bpstab3, penalty = "AIC")
## no breakpoints are estimated
```

# Figure Settings
```{r, echo=FALSE, include=FALSE}
green_scale <- c("#97e196", "#6cc08b", "#4c9b82", "#217a79", "#105965", "#074050") #make a vector of colors
colors <- c("#88CCEE", "#CC6677","#DDCC77","#117733","#332288","#AA4499","#44AA99","#999933","#882255","#661100","#6699CC","#888888")
theme_set(theme_classic()) #set the theme
```

# **Stability Figures**

## Stability: Mean and Variance
```{r, fig.width =10, fig.height=4, echo=FALSE, fig.cap='**Figure 1:** Points show the mean stability (A), total cover (B), and temporal variance (C) for each treatment. Bars show one standard error above and below the mean. Treatment abbreviations are as follows: O = No herbivores, W = Wild mesoherbivores, MW = Megaherbivores and wild mesoherbivores, C = cattle, MWC = Megaherbivores, wild mesoherbivores, and cattle, WC = Wild mesoherbivores and cattle'}

#graph the mean variance by treatment
v <- ggplot(meanvar, aes(x=TREATMENT, y=meanvar)) +
  geom_point(size=3) +
  geom_errorbar(aes(ymin = meanvar-SEvar, ymax = meanvar+SEvar), width=0.25) +
  ylab("Temporal Variance") + xlab("Treatment") +
  annotate("text", x =1, y=17000, label = "a") +
  annotate("text", x =2, y=15050, label = "ab") +
  annotate("text", x =3, y=12900, label = "ab") +
  annotate("text", x =4, y=11600, label = "bc") +
  annotate("text", x =5, y=9500, label = "c") +
  annotate("text", x =6, y=8500, label = "c")

#graph the mean total pin hits by treatment
b <- ggplot(avg_biomass, aes(x=TREATMENT, y=avgbio)) +
  geom_point(size=3) +
  geom_errorbar(aes(ymin=avgbio-SEbio, ymax=avgbio+SEbio), width = 0.2) + #include standard error bars
  ylab("Total Pin Hits") + xlab("Treatment") +
  annotate("text", x =1, y=1320, label = "a") +
  annotate("text", x =2, y=1290, label = "a") +
  annotate("text", x =3, y=1230, label = "a") +
  annotate("text", x =4, y=1110, label = "b") +
  annotate("text", x =5, y=1065, label = "b") +
  annotate("text", x =6, y=1030, label = "b")

## visualize mean stability & standard error
s <- ggplot(mean_stability, aes(x=TREATMENT, y=mean_st)) +
  geom_point(size=3) +
  geom_errorbar(aes(ymin = mean_st-SEst, ymax=mean_st+SEst), width = 0.2) + #add standard error bars
  ylab("Stability (mean/sd)") + xlab("Treatment") + #label axes
  annotate("text", x =1, y=5.56, label = "a") +
  annotate("text", x =2, y=4.56, label = "ab") +
  annotate("text", x =3, y=4, label = "bc") +
  annotate("text", x =4, y=4.1, label = "bc") +
  annotate("text", x =5, y=3.8, label = "bc") +
  annotate("text", x =6, y=3.5, label = "c")
  #theme(text = element_text(size = 14)) #change font size

## plot 3 panel figure of stability, total pin hits, and temporal variance
ggarrange(s, b, v, 
          labels = c("A", "B", "C"),
          ncol = 3, nrow = 1, 
          align = "hv")
```

## Mean-Variance relationships
```{r}
ggplot(meanvar, aes(x=log(meanbio), y= log(meanvar))) +
  geom_point(size = 3, aes(color= TREATMENT)) +
  geom_abline() +
  scale_color_manual(values = green_scale) + #change color scheme
  coord_cartesian(xlim = c(6.5,7.5), ylim = c(6.5,9.75))
```


## Total Cover Time Series
```{r, echo=FALSE, fig.align='center', fig.cap='**Figure 2:** Points represent the mean stability of total cover (temporal mean/temporal standard deviation) for each grazing treatment at each point in time. Treatment abbreviations are as follows: O = No herbivores, W = Wild mesoherbivores, MW = Megaherbivores and wild mesoherbivores, C = cattle, MWC = Megaherbivores, wild mesoherbivores, and cattle, WC = Wild mesoherbivores and cattle'}

#graph the time series of total cover 
ggplot(meantotcov, aes(x=Date_final, y=Mean_TotCov, col=TREATMENT)) + #separate treatments by color
  geom_line(size = 0.5) +
  geom_point(aes(y=Mean_TotCov)) +
  scale_color_manual(values = green_scale) + #change color scheme
  ylab("Total Cover (# Pin Hits)") + xlab("Date") + labs(col = "Treatment") + #add labels
  theme(legend.title = element_text(size=12)) + theme(text = element_text(size = 14)) #change font sizes

```



## Stability Over a Moving Window - Annual Sampling
```{r, echo=FALSE, fig.width =12, fig.height=8, fig.cap='**Figure 3:** Stability is calculated over a sliding window of lengths 3 years (A), 5 years (B), 7 years (C), and 10 years (D). Points show the mean stability calculated for each time window. Stability was calculated using data from the annual samplings in June only in order to have consistent sampling frequency.'}

ggplot(stab_mw_tx, aes(x=timestep, y=mean_stability, color = TREATMENT)) +
  geom_line() +
  geom_point() +
  scale_color_manual(values = colors) + #change color scheme
  ylab("Mean Stability") + xlab("Timestep") +
  facet_wrap(~window_size)

```


## All Mechanisms Combined
```{r, echo=FALSE, fig.width =10, fig.height=10}

syngraz <- ggplot(syn_stab, aes(x=TREATMENT , y=mean_value, shape= Metric_Name)) +
  geom_point(size=3) +
  scale_color_manual(values = colors, labels = c("Gross", "Loreau")) +
  geom_errorbar(aes(ymin = mean_value-SE_value, ymax=mean_value+SE_value), width = 0.3) +
  ylab("Synchrony") + xlab("Treatment") +  
  theme(legend.title = element_text(size=12)) +  theme(text = element_text(size = 14)) + #change font sizes
  labs(col = "Treatment", shape = "Synchrony Metric") +
    scale_shape_discrete(labels = c("Gross", "Loreau")) +#rename synchrony metrics in legend
#add legend titles
  annotate("text", x =1, y=0.125, label = "a") +
  annotate("text", x =2, y=0.14, label = "ab") +
  annotate("text", x =3, y=0.205, label = "bc") +
  annotate("text", x =4, y=0.185, label = ".bc") +
  annotate("text", x =5, y=0.231, label = "c") +
  annotate("text", x =6, y=0.24, label = "c") +
  ## gross synchrony
  annotate("text", x =1, y=0.055, label = "a") +
  annotate("text", x =2, y=0.1, label = "ab") +
  annotate("text", x =3, y=0.11, label = "ab") +
  annotate("text", x =4, y=0.08, label = "ab") +
  annotate("text", x =5, y=0.12, label = ".b") +
  annotate("text", x =6, y=0.14, label = "b")
  #scale_color_discrete(labels = c("Gross", "Loreau")) #rename synchrony metrics in legend

synstab <- ggplot(syn_stab, aes(x=mean_value , y=mean_st, col = TREATMENT, shape=Metric_Name)) +
  stat_smooth(method = "lm", col = "black") +
  geom_point(size=3) +
  scale_color_manual(values = green_scale) +
  geom_errorbar(aes(ymin=mean_st-SEst, ymax=mean_st+SEst), width = 0.005) + #add standard error bars
  geom_errorbarh(aes(xmin = mean_value-SE_value, xmax=mean_value+SE_value), height = 0.1) + #add standard error bars
  ylab("Stability") + xlab("Synchrony") +  #label axes
  theme(legend.title = element_text(size=12)) + theme(text = element_text(size = 14)) + #change font sizes
  labs(col = "Treatment", shape = "Synchrony Metric") +
  scale_shape_discrete(labels = c("Gross", "Loreau")) +
  annotate("text", x =0.15, y=6.25, label = "Loreau: y = -13.1211x + 6.1034") +
  annotate("text", x =0.15, y=6, label = "R2 = 0.7702, p-value = 1.05x10^-6") +
  annotate("text", x =0.15, y=5.75, label = "Gross: y = -13.6138x + 5.0258") +
  annotate("text", x =0.15, y=5.5, label = "R2 = 0.3176 , p-value = 0.00875")

domgraz <- ggplot(avg_BPdom, aes(x=TREATMENT, y=avg_dom)) +
  geom_point(size = 3) +
  geom_errorbar(aes(ymin=avg_dom-SE, ymax=avg_dom+SE), width = 0.25) +
  xlab("Treatment") + ylab("Berger-Parker Dominance") +  
  theme(legend.title = element_text(size=12)) +  theme(text = element_text(size = 14)) + #+ #change font sizes
  annotate("text", x =2, y=0.29, label = "No significant effects")

domstab <- ggplot(dom_stab, aes(x=avg_dom, y=mean_st, col=TREATMENT)) +
  stat_smooth(method = "lm", col = "black") +
  geom_point(size = 3) +
  ylab("Stability") + xlab("Berger-Parker Dominance") +
  geom_errorbarh(aes(xmin=avg_dom-SE, xmax=avg_dom+SE)) +
  geom_errorbar(aes(ymin=mean_st-SEst, ymax=mean_st+SEst)) +
  scale_color_manual(values = green_scale) +
  theme(legend.title = element_text(size=12)) +
  theme(text = element_text(size = 14)) +
  labs(col = "Treatment") + #change legend title
  annotate("text", x =0.31, y=6, label = "y = 8.752x + 1.029") +
  annotate("text", x =0.31, y=5.65, label = "R2 = 0.1431, p-value = 0.0678")

rich1 <- ggplot(richstab, aes(x=TREATMENT, y=meanSR_tx)) +
  geom_point(size=3) +
  geom_errorbar(aes(ymin=meanSR_tx-SESR_tx, ymax=meanSR_tx+SESR_tx), width=0.25) +
  ylab("Species Richness") +xlab("Treatment") +
  theme(legend.title = element_text(size=12)) +  theme(text = element_text(size = 14)) + #change font sizes
  annotate("text", x =2, y=18.5, label = "No significant effects")

richstability <- ggplot(richstab, aes(x=meanSR_tx, y=mean_st, color=TREATMENT)) +
  stat_smooth(method = "lm", col = "black") +
  geom_point(size=3) +
  geom_errorbarh(aes(xmin=meanSR_tx-SESR_tx, xmax=meanSR_tx+SESR_tx)) +
  geom_errorbar(aes(ymin=mean_st-SEst, ymax=mean_st+SEst), width=0.15) +
  scale_color_manual(values = green_scale) +
  ylab("Mean Stability") +xlab("Species Richness") +
  theme(legend.title = element_text(size=12)) +  theme(text = element_text(size = 14)) + #change font sizes
  annotate("text", x =20, y=6, label = "y = -0.1836x + 7.5922") +
  annotate("text", x =20, y=5.7, label = "R2 = 0.00215, p-value = 0.3238")

ggarrange(syngraz, synstab, domgraz, domstab, rich1, richstability,
          #labels = c("A", "B", "C", "D", "E"),
          ncol = 2, nrow = 3,
          #align = "hv", 
          common.legend = TRUE, 
          labels = c("A", "B", "C", "D", "E", "F"), 
          #vjust = -0.25,
          legend = "bottom")

```


## Synchrony over a moving window

```{r, echo=FALSE, fig.width =12, fig.height=6, fig.cap='**Figure 6:** Loreau synchrony calculated using a moving window of 5 years (A), 7 years (B), and 10 years (C).'}

ggplot(syn_mw_tx, aes(x=timestep, y=meanloreau, color = TREATMENT)) +
  geom_line() +
  geom_point() +
  scale_color_manual(values = colors) + #change color scheme
  ylab("Mean Loreau Synchrony") + xlab("Timestep") +
  facet_wrap(~window_size)

```


## Dominance over time
```{r, echo=FALSE, fig.align='center', fig.cap='**Figure 8:** Lines show the mean Berger-Parker dominance across time for each grazing treatment. Treatment abbreviations are as follows: 0 = No herbivores, W = Wild mesoherbivores, MW = Megaherbivores and wild mesoherbivores, C = cattle, MWC = Megaherbivores, wild mesoherbivores, and cattle, WC = Wild mesoherbivores and cattle'}
## Graph dominance over time
ggplot(BP_dom, aes(x=Date_final, y=mean_dom, col=TREATMENT)) +
  geom_line(size = 0.5) +
  theme_bw() +
  #scale_color_brewer(palette = "Dark2") +
  ylab("Berger-Parker Dominance") + xlab("Date") +
  scale_color_manual(values = green_scale) +
  theme(legend.title = element_text(size=12)) +
  theme(text = element_text(size = 14)) +
  labs(col = "Treatment") #change legend title

```

## Dominance over a moving window
```{r, echo=FALSE}

ggplot(dominance_mw, aes(x=timestep, y=mean_dominance, color = TREATMENT)) +
  geom_line() +
  geom_point() +
  scale_color_manual(values = colors) + #change color scheme
  ylab("Mean Berger-Parker Dominance") + xlab("Timestep") +
  facet_wrap(~window_size)

```

## Dominant species over time
```{r, echo=FALSE, fig.width =14, fig.height=8, fig.cap='**Figure 10:** Points show the mean pin hits for each species at a point in time. Included species were in the top 2 most abundant species in a given treatment at some point in the time series.'}
domsp <- domsp[-1031,]
domsp$TREATMENT <- as.factor(domsp$TREATMENT) #change treatment to factor
domsp$TREATMENT <- factor(domsp$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))

ggplot(domsp, aes(x=Date_final, y=mean, color=SPECIES)) +
  geom_line() +
  geom_point() +
  facet_wrap(~TREATMENT) +
  scale_color_manual(values = colors) +
  xlab("Date") + ylab("Mean Pin Hits")

```

## Dominant Species, Rank, & Stability
```{r, echo=FALSE, fig.width =12, fig.height=6, fig.cap='**Figure 11:** Species stability (mean/sd) for species that were in the top 2 most abundant species in a given treatment at any point in the time series. Bars indicate one standard error above and below the mean. The mean rank of a species was obtained by ranking their abundance in a treatment and taking the mean rank of each species across the time series. '}

dominant.sp <- dominant.sp[-40,]
dominant.sp$TREATMENT <- as.factor(dominant.sp$TREATMENT) #change treatment to factor
dominant.sp$TREATMENT <- factor(dominant.sp$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))


ggplot(dominant.sp, aes(x=rank, y=stability, col=SPECIES)) +
  geom_point(size=2) +
  ylab("Species Stability") + xlab("Species Mean Rank over Time") +
  #theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  scale_color_manual(values = colors) +
  geom_errorbar(aes(ymin=stability-SE, ymax=stability+SE), width=0.75) +
  #theme(legend.title = element_text(size=12)) +
  #theme(text = element_text(size = 14)) +
  labs(col = "Species") + #change legend title
  facet_wrap(~TREATMENT) 
```


## Richness over time
```{r, echo=FALSE, fig.cap='**Figure 14:** Mean richness over time.'}

ggplot(rich_time, aes(x=Date_final, y=meanrich, color = TREATMENT)) +
  geom_line(size = 0.5) +
  geom_point() +
  theme_bw() +
  #scale_color_brewer(palette = "Dark2") +
  ylab("Richness") + xlab("Date") +
  scale_color_manual(values = green_scale) +
  theme(legend.title = element_text(size=12)) +
  theme(text = element_text(size = 14)) +
  labs(col = "Treatment") #change legend title

```
