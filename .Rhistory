ylab("Mean Stability") +xlab("Average Species Richness") +
theme_bw()
ggplot(richstab, aes(x=meanSR_tx, y=mean_st, color=TREATMENT)) +
geom_point() +
geom_errorbarh(aes(xmin=meanSR_tx-SESR_tx, xmax=meanSR_tx+SESR_tx)) +
geom_errorbar(aes(ymin=mean_st-SEst, ymax=mean_st+SEst), width=0.15) +
ylab("Mean Stability") +xlab("Average Species Richness") +
theme_bw()
ggplot(richstab, aes(x=meanSR_tx, y=mean_st, color=TREATMENT)) +
geom_point() +
geom_errorbarh(aes(xmin=meanSR_tx-SESR_tx, xmax=meanSR_tx+SESR_tx)) +
geom_errorbar(aes(ymin=mean_st-SEst, ymax=mean_st+SEst), width=0.15) +
scale_color_manual(values = green_scale)
ggplot(richstab, aes(x=meanSR_tx, y=mean_st, color=TREATMENT)) +
geom_point() +
geom_errorbarh(aes(xmin=meanSR_tx-SESR_tx, xmax=meanSR_tx+SESR_tx)) +
geom_errorbar(aes(ymin=mean_st-SEst, ymax=mean_st+SEst), width=0.15) +
scale_color_manual(values = green_scale) +
ylab("Mean Stability") +xlab("Average Species Richness") +
theme_bw()
ggplot(richstab, aes(x=meanSR_tx, y=mean_st, color=TREATMENT)) +
geom_point(size=3) +
geom_errorbarh(aes(xmin=meanSR_tx-SESR_tx, xmax=meanSR_tx+SESR_tx)) +
geom_errorbar(aes(ymin=mean_st-SEst, ymax=mean_st+SEst), width=0.15) +
scale_color_manual(values = green_scale) +
ylab("Mean Stability") +xlab("Average Species Richness") +
theme_bw()
domsp <- domsp[-1031,]
domsp$TREATMENT <- as.factor(domsp$TREATMENT) #change treatment to factor
domsp$TREATMENT <- factor(domsp$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))
ggplot(domsp, aes(x=Date_final, y=mean, color=SPECIES)) +
geom_line() +
geom_point() +
facet_wrap(~TREATMENT) +
scale_color_manual(values = colors) +
xlab("Date") + ylab("Mean Pin Hits")
## Load Packages, Read in Data ##
## set working directory
setwd("~/Repositories/klee-stability")
## Load Packages, Read in Data ##
## set working directory
setwd("~/Repositories/klee-stability")
## Load packages
library(tidyverse)
library(lubridate)
library(codyn)
library(tsvr)
library(RColorBrewer)
library(forcats)
library(knitr)
library(bookdown)
library(ggpubr)
library(data.table)
source("google-drive-function.R")
## create a function to calculate standard error
calcSE<-function(x){
x2<-na.omit(x)
sd(x2)/sqrt(length(x2))
}
## read in data, first hits (1999-2015), using lumped species data. Groupings determined by Kari, Lauren, & Corrina
#https://drive.google.com/file/d/10xNVrnnDDWbNBJM8nWLEm7keCMcJoXAG/view?usp=sharing
kleedat <- read_csv_gdrive("10xNVrnnDDWbNBJM8nWLEm7keCMcJoXAG") %>%
tbl_df()
domsp <- domsp[-1031,]
domsp$TREATMENT <- as.factor(domsp$TREATMENT) #change treatment to factor
domsp$TREATMENT <- factor(domsp$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))
ggplot(domsp, aes(x=Date_final, y=mean, color=SPECIES)) +
geom_line() +
geom_point() +
facet_wrap(~TREATMENT) +
scale_color_manual(values = colors) +
xlab("Date") + ylab("Mean Pin Hits")
View(domsp)
## Load Packages, Read in Data ##
## set working directory
setwd("~/Repositories/klee-stability")
## Load packages
library(tidyverse)
library(lubridate)
library(codyn)
library(tsvr)
library(RColorBrewer)
library(forcats)
library(knitr)
library(bookdown)
library(ggpubr)
library(data.table)
## source cleaned data
source("klee_data_cleaning_current.R")
## Calculate Community Stability ##
## calc community stability metric for each plot
commstab <- community_stability(klee_long,
time.var = "Date_numeric",
abundance.var = "Pin_Hits",
replicate.var = "Unique_ID")
## join with treatment info & calculate CV
stability <- left_join(commstab, treats, by = "Unique_ID") %>% #join community stability with treatment info
mutate(CV = 1/stability) #calculate the CV by taking the inverse of stability
rm(commstab)
## create a dataframe with mean & standard error of stability & CV by treatment
mean_stability <- stability %>%
group_by(TREATMENT) %>%
summarize(mean_st = mean(stability), SEst = calcSE(stability), mean_cv = mean(CV), SECV = calcSE(CV))
## reorder treatments to match grazing pressure.
mean_stability$TREATMENT <- as.factor(mean_stability$TREATMENT) #change treatment to factor
mean_stability$TREATMENT <- factor(mean_stability$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))
## Calculate Variance
## calculate the variance of each plot over time
varian <- klee_long %>%
group_by(TREATMENT, Unique_ID) %>%
summarise(variance = var(Pin_Hits)) %>%
group_by(TREATMENT) %>%
summarise(meanvar = mean(variance), SEvar = calcSE(variance)) ## calculate mean and standard error
variance <- klee_long %>%
group_by(TREATMENT, Unique_ID) %>%
summarise(variance = var(Pin_Hits))
pinhits <- meantotcov %>%
group_by(TREATMENT, Unique_ID) %>%
summarize(pinhits = mean(Mean_TotCov))
## reorder treatments to match grazing pressure.
varian$TREATMENT <- as.factor(varian$TREATMENT) #change treatment to factor
sort(unique(klee_long$Date_final)) #sort unique sampling dates
## create the bi-annual data frame (before 2011)
biannual <- klee_long %>%
filter(Date_numeric < 20110601)
annual1 <- klee_long[klee_long$Date_final %like% "-06", ]        # Extract matching rows with %like%
annual2 <- klee_long[klee_long$Date_final %like% "-05", ]
annual_all <- rbind(annual1, annual2)
annual <- rbind(annual1, annual2) %>%
filter(Date_numeric < 20110601)
sort(unique(annual$Date_final))
rm(list = c("biannual", "annual1", "annual2", "annual", "annual_stab", "biannual_stab", "stabfreq_test"))
## Calculate Stability over a Moving Window ##
## create function
movingwindow_func <- function(input_data, timestep, ...) { ## function inputs = data frame and number of time steps
n_samples <- length(unique(input_data$Date_final)) ## number of sampling points
n_windows <- n_samples - timestep + 1 ## how many windows to iterate over
movingwindow <- data.frame(matrix(ncol=3,nrow=(n_windows*length(unique(input_data$Unique_ID))))) ## create empty dataframe to contain output ## dimensions = # cols (3) x (uniqueID x timesteps)
colnames(movingwindow) <- c("Unique_ID", "stability", "timestep")
sample_points <- sort(unique(input_data$Date_numeric)) ## create ordered list of sample points
n_plots <- length(unique(input_data$Unique_ID)) ## number of unique plots
for (i in 1:n_windows){
temp_samplepts <- sample_points[i:(i+timestep-1)] ## create a vector of sample points for each iteration
temp <- input_data %>%
filter(Date_numeric %in% temp_samplepts) ## filter the correct sample points from input data to run through the community stability function
temp_commstab <- community_stability(temp,  ## run the community stability function from codyn
time.var = "Date_numeric",
abundance.var = "Pin_Hits",
replicate.var = "Unique_ID")
temp_commstab$timestep <- i ## create a column for timestep in the temporary data frame
movingwindow[((i-1)*n_plots + 1):(i*n_plots),] <- temp_commstab ## add stability calculations for one iteration to the moving window data frame
## ((i-1)*n_plots + 1):(i*n_plots) -> where to put each iteration of the loop
}
return(movingwindow) ## retrieve data frame at the end
}
annual_stab3 <- movingwindow_func(input_data = annual_all, timestep = 3)
annual_stab5 <- movingwindow_func(input_data = annual_all, timestep = 5)
annual_stab7 <- movingwindow_func(input_data = annual_all, timestep = 7)
annual_stab10 <- movingwindow_func(input_data = annual_all, timestep = 10)
View(annual_stab10)
View(annual_stab3)
## Calculate Synchrony Metrics ##
## Calculate Loreau synchrony metric
loreau_synchrony <- synchrony(
klee_long,
time.var = "Date_numeric",
species.var = "SPECIES",
abundance.var = "Pin_Hits",
metric = "Loreau",
replicate.var = "Unique_ID"
)
colnames(loreau_synchrony) <- c("Unique_ID", "loreau_synchrony") #rename columns
## Calculate Gross synchrony metric
gross_synchrony <- synchrony(
klee_long,
time.var = "Date_numeric",
species.var = "SPECIES",
abundance.var = "Pin_Hits",
replicate.var = "Unique_ID",
metric="Gross")
colnames(gross_synchrony) <- c("Unique_ID", "gross_synchrony") #rename columns
## join two synchrony metrics into one data frame
synchrony <- left_join(loreau_synchrony, gross_synchrony, by = "Unique_ID")
## join with treatment data
synchrony_tx <- inner_join(synchrony, treats, by = "Unique_ID")
synchrony_stability <- left_join(synchrony, stability, by = "Unique_ID")
rm(loreau_synchrony)
rm(gross_synchrony)
## calculate mean & SE of metrics to get ready for graphing
mean_synchrony <- left_join(synchrony, treats, by = "Unique_ID") %>%
pivot_longer(cols = loreau_synchrony:gross_synchrony, names_to = "Metric_Name", values_to = "Synchrony") %>% #pivot to long format
group_by(TREATMENT, Metric_Name) %>%
summarise(mean_value = mean(Synchrony), SE_value = calcSE(Synchrony))
## reorder treatments to match grazing pressure.
mean_synchrony$TREATMENT <- as.factor(mean_synchrony$TREATMENT) #change treatment to factor
mean_synchrony$TREATMENT <- factor(mean_synchrony$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))
## join synchrony & stability data frames to get ready for graphing
syn_stab <- inner_join(mean_synchrony, mean_stability, by = "TREATMENT")
## Synchrony over a Moving Window ##
## create function
synchronymw_func <- function(input_data, timestep, ...) { ## function inputs = data frame and number of time steps
n_samples <- length(unique(input_data$Date_final)) ## number of sampling points
n_windows <- n_samples - timestep + 1 ## how many windows to iterate over
mw_synchrony <- data.frame(matrix(ncol=4,nrow=(n_windows*length(unique(input_data$Unique_ID))))) ## create empty dataframe to contain output ## dimensions = # cols (3) x (uniqueID x timesteps)
colnames(mw_synchrony) <- c("Unique_ID", "loreau_synchrony", "timestep", "gross_synchrony")
sample_points <- sort(unique(input_data$Date_numeric)) ## create ordered list of sample points
n_plots <- length(unique(input_data$Unique_ID)) ## number of unique plots
for (k in 1:n_windows){
temp_samplepts <- sample_points[k:(k+timestep-1)] ## create a vector of sample points for each iteration
temp <- input_data %>%
filter(Date_numeric %in% temp_samplepts) ## filter the correct sample points from input data to run through the community stability function
## Calculate Loreau synchrony metric
temp_lsyn <- synchrony(
temp,
time.var = "Date_numeric",
species.var = "SPECIES",
abundance.var = "Pin_Hits",
metric = "Loreau",
replicate.var = "Unique_ID"
)
colnames(temp_lsyn) <- c("Unique_ID", "loreau_synchrony") #rename columns
temp_lsyn$timestep <- k ## create a column for timestep in the temporary data frame
## Calculate Gross synchrony metric
temp_gsyn <- synchrony(
temp,
time.var = "Date_numeric",
species.var = "SPECIES",
abundance.var = "Pin_Hits",
replicate.var = "Unique_ID",
metric="Gross")
colnames(temp_gsyn) <- c("Unique_ID", "gross_synchrony") #rename columns
temp_gsyn$timestep <- k ## create a column for timestep in the temporary data frame
## join synchrony dataframes together
tempsynch <- left_join(temp_lsyn, temp_gsyn, by= c("Unique_ID", "timestep"))
mw_synchrony[((k-1)*n_plots + 1):(k*n_plots),] <- tempsynch ## add synchrony calculations for one iteration to the moving window data frame
## ((i-1)*n_plots + 1):(i*n_plots) -> where to put each iteration of the loop
}
return(mw_synchrony) ## retrieve data frame at the end
}
#synchrony3 <- synchronymw_func(input_data = annual_all, timestep = 3)
#this returned the message "One or more species has non-varying abundance within a subplot and has been omitted" many times. Probably too short of a timescale to run the synchrony functions over
synchrony4 <- synchronymw_func(input_data = annual_all, timestep = 4)
#got same error message, but only once
synchrony5 <- synchronymw_func(input_data= annual_all, timestep = 5)
#this only returned 11 timesteps. Not sure what happened?
#this is because it has only the June sampling points.
synchrony7 <- synchronymw_func(input_data = annual_all, timestep = 7)
synchrony10 <- synchronymw_func(input_data = annual_all, timestep = 10)
## Calculate Timescale Specific VR ##
#set up data frame to put tsvr into
outnames <- c("Unique_ID", "TREATMENT", "classicVR", "longVR", "shortVR") #column names
siteout <- as.data.frame(matrix(nrow=0, ncol = 5)) #make empty dataframe
names(siteout) <- outnames #set names for empty dataframe
plots <- unique(klee_long$Unique_ID) #make vector of unique plots
## Use for loop to calculate TSVR for each plot
for (i in 1:length(plots)) {
#subset by replicate (gives all observations from one plot over time)
plot <- subset(klee_long, Unique_ID == plots[i]) %>%
tbl_df()
#select species and fill 0's
plot2 <- plot %>%
select(Date_numeric, SPECIES, Pin_Hits) %>% #selecting only these three columns
spread(SPECIES, Pin_Hits, fill = 0) #changing to wide format
#transpose the data
dat <- t(as.matrix(plot2[,2:dim(plot2)[2]]))
#create a dataframe with replicate info to attach VR metrics to
VR_plots <- plot %>%
select(Unique_ID, TREATMENT, BLOCK) %>%
unique()
#calculate classic VR
res0 <- vreq_classic(dat)
VR_plots$classicVR <- res0[[3]]
#calculate tsvr
res <- tsvreq_classic(dat)
#aggregate short vs. long variance ratios
resLong <- aggts(res, res$ts[res$ts>=4]) #grabbing tsvr with time period >= 4 years
resShort <- aggts(res, res$ts[res$ts<4]) #grabbing tsvr with time period <4 years
#attach short & long variance ratios
VR_plots$longVR <- resLong[[3]]
VR_plots$shortVR <- resShort[[3]]
#append to external dataframe
siteout<-rbind(siteout, VR_plots)
}
#rename data frame
tsVR <- siteout
## Calculate the mean and standard error of VR metrics
meantsVR <- tsVR %>%
pivot_longer(cols = classicVR:shortVR, names_to = "VR_type", values_to = "VR_value" ) %>% #change to long format
group_by(TREATMENT, VR_type) %>%
summarise(meanVR = mean(VR_value), SEVR = calcSE(VR_value))
#reorder treatments to match grazing pressure.
meantsVR$TREATMENT <- as.factor(meantsVR$TREATMENT) #change treatment to factor
meantsVR$TREATMENT <- factor(meantsVR$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))
## Compare VR & Stability ##
## join mean stability & mean tsVR data frames.
tsvr_stab <- inner_join(mean_stability, meantsVR, by = "TREATMENT")
## Create a data frame with all synchrony and variance ratio metrics in order to make a table.
## change mean synchrony to wide format
meansyn <- mean_synchrony %>%
pivot_wider(names_from = "Metric_Name", values_from = "mean_value") %>% #make unique columns for each synchrony metric
group_by(TREATMENT) %>%
summarise(GS=mean(gross_synchrony, na.rm = T), LS=mean(loreau_synchrony, na.rm = T)) #calculate the mean for each treatment and remove NAs to get rid of the weird column format that pivot wider creates here
## change mean tsvr to wide format
tsvrmean <- tsvr_stab %>%
pivot_wider(names_from = "VR_type", values_from = "meanVR") %>% #make unique column for each variance ratio metric
group_by(TREATMENT) %>%
summarise(classic=mean(classicVR, na.rm = TRUE), short = mean(shortVR, na.rm=TRUE), long=mean(longVR, na.rm = TRUE)) #calculate the mean for each treatment and remove NAs to get rid of the weird column format that pivot wider creates here
## join synchrony and variance ratio data frames
comp_dyn <- left_join(meansyn, tsvrmean, by = "TREATMENT")
## Calculate Berger-Parker Dominance ##
#BP dominance: d = Nmax/N (relative abundance of most dominant species)
BP_dom <- klee_long %>%
group_by(TREATMENT, Unique_ID, Date_final) %>% #group by treatment, plot, and date
mutate(rank = rank(Pin_Hits, na.last = NA, ties.method = "average")) %>% #rank species in order of abundance
mutate(tot_abund = sum(Pin_Hits)) %>% #calculate total abundance
filter(rank == max(rank)) %>% #only include most abundant species in each plot
summarise(BP_dominance = Pin_Hits/tot_abund) %>% #calculate Berger-Parker dominance index
group_by(TREATMENT, Date_final) %>% #group by treatment and date
summarise(mean_dom = mean(BP_dominance), SEdom = calcSE(BP_dominance)) #calculate mean and SE for each treatment at each date
BP_dom2 <- klee_long %>%
group_by(TREATMENT, Unique_ID, Date_final) %>% #group by treatment, plot, and date
mutate(rank = rank(Pin_Hits, na.last = NA, ties.method = "average")) %>% #rank species in order of abundance
mutate(tot_abund = sum(Pin_Hits)) %>% #calculate total abundance
filter(rank == max(rank)) %>% #only include most abundant species in each plot
summarise(BP_dominance = Pin_Hits/tot_abund) %>% #calculate Berger-Parker dominance index
group_by(TREATMENT, Unique_ID, Date_final) %>% #group by treatment and date
summarise(mean_dom = mean(BP_dominance), SEdom = calcSE(BP_dominance))
#reorder treatments to match grazing pressure.
BP_dom$TREATMENT <- as.factor(BP_dom$TREATMENT) #change treatment to factor
BP_dom$TREATMENT <- factor(BP_dom$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))
## calculate the mean dominance index by treatment
avg_BPdom <- BP_dom %>%
group_by(TREATMENT) %>% #group by treatment
summarise(avg_dom = mean(mean_dom), SE = calcSE(mean_dom)) #take mean across time for each treatment
dominance <- BP_dom2 %>%
group_by(Unique_ID) %>%
summarize(dominance = mean(mean_dom))
dominance <- left_join(dominance, treats, by = "Unique_ID")
dominance <- left_join(dominance, stability, by = c("Unique_ID", "BLOCK", "TREATMENT"))
#reorder treatments to match grazing pressure.
avg_BPdom$TREATMENT <- as.factor(avg_BPdom$TREATMENT) #change treatment to factor
avg_BPdom$TREATMENT <- factor(avg_BPdom$TREATMENT, levels = c("0", "W",  "MW",  "C", "MWC", "WC"))
## join stability & dominance data frames
dom_stab <- inner_join(mean_stability, avg_BPdom, by = "TREATMENT")
## use annual all data frame
test <- annual_all %>%
group_by(TREATMENT, Unique_ID, Date_final) %>% #group by treatment, plot, and date
mutate(rank = rank(Pin_Hits, na.last = NA, ties.method = "average")) %>% #rank species in order of abundance
mutate(tot_abund = sum(Pin_Hits)) %>% #calculate total abundance
filter(rank == max(rank)) %>% #only include most abundant species in each plot
summarise(BP_dominance = Pin_Hits/tot_abund) %>% #calculate Berger-Parker dominance index
group_by(TREATMENT, Date_final) %>% #group by treatment and date
summarise(mean_dom = mean(BP_dominance), SEdom = calcSE(BP_dominance)) #calculate mean and SE for each treatment at each date
dominancemw_func <- function(input_data, timestep, ...) { ## function inputs = data frame and number of time steps
n_samples <- length(unique(input_data$Date_final)) ## number of sampling points
n_windows <- n_samples - timestep + 1 ## how many windows to iterate over
movingwindow <- data.frame(matrix(ncol=5,nrow=(n_windows*length(unique(input_data$Unique_ID))))) ## create empty dataframe to contain output ## dimensions = # cols (3) x (uniqueID x timesteps)
colnames(movingwindow) <- c("TREATMENT", "Unique_ID", "Date_final", "BP_dominance","timestep")
sample_points <- sort(unique(input_data$Date_numeric)) ## create ordered list of sample points
n_plots <- length(unique(input_data$Unique_ID)) ## number of unique plots
for (i in 1:n_windows){
temp_samplepts <- sample_points[i:(i+timestep-1)] ## create a vector of sample points for each iteration
temp <- input_data %>%
filter(Date_numeric %in% temp_samplepts) ## filter the correct sample points from input data to run through the community stability function
temp_dom <- temp %>%
group_by(TREATMENT, Unique_ID, Date_final) %>%
mutate(rank = rank(Pin_Hits, na.last = NA, ties.method = "average")) %>% #rank species in order of abundance
mutate(tot_abund = sum(Pin_Hits)) %>% #calculate total abundance
filter(rank == max(rank)) %>% #only include most abundant species in each plot
summarise(BP_dominance = Pin_Hits/tot_abund) #calculate Berger-Parker dominance index
temp_dom$timestep <- i ## create a column for timestep in the temporary data frame
movingwindow[((i-1)*n_plots + 1):(i*n_plots),] <- temp_dom ## add stability calculations for one iteration to the moving window data frame
## ((i-1)*n_plots + 1):(i*n_plots) -> where to put each iteration of the loop
}
return(movingwindow) ## retrieve data frame at the end
}
dom5 <- dominancemw_func(input_data = annual_all, timestep = 5)
## make for-loop to calculate dominant species by treatment
## rank species in order of abundance with 1 being most abundant.
rankneg <- klee_long %>%
group_by(TREATMENT, Unique_ID, Date_final) %>%
mutate(rank = rank(-Pin_Hits, na.last = NA, ties.method = "average")) %>% #rank species in order of abundance
mutate(tot_abund = sum(Pin_Hits)) #calculate total abundance
trt <- unique(klee_long$TREATMENT) ## create vector of treatments for loop to iterate over
dominant.sp <- data.frame(SPECIES=NA, stability=NA, rank=NA, SE=NA, TREATMENT=NA) ## create empty dataframe to contain output. Don't know exact number of rows, will need to just make empty columns and bind in loop
domsp <- data.frame(TREATMENT=NA, Date_final=NA, SPECIES=NA,mean=NA, SE=NA)
## create for loop
for (j in 1:length(trt)) {
## pull out the jth sampling unit from the data
temp <- rankneg %>%
filter(TREATMENT == trt[j])
## filter to contain only the top 2 most abundant species at any point in the time series
ranktemp <- temp %>%
filter(rank < 3)
## make a unique vector of top 2 abundant sp at any point
tempsp <- unique(ranktemp$SPECIES)
## filter by top 2 species
tempspdf <- temp %>%
filter(SPECIES %in% tempsp) %>%
group_by(TREATMENT, Date_final, SPECIES) %>%
summarize(mean=mean(Pin_Hits), SE=calcSE(Pin_Hits))
## save this to a new data frame
domsp <- rbind(tempspdf, domsp)
## filter entire time series by top 2 species to get their full time series. Calculate stability
tempstab <- temp %>%
filter(SPECIES %in% tempsp) %>%
group_by(BLOCK, SPECIES) %>%
summarise(temp_mean = mean(Pin_Hits), sdhits = sd(Pin_Hits), sp_stability = temp_mean/sdhits, meanrank = mean(rank)) %>%
ungroup() %>%
group_by(SPECIES) %>%
summarise(stability = mean(sp_stability), rank=mean(meanrank), SE = calcSE(sp_stability)) %>%
mutate(TREATMENT = trt[j])
## save stability calculations in new dataframe
dominant.sp <- rbind(tempstab, dominant.sp)
}
## Change mean rank to integer
dominant.sp <- dominant.sp %>%
mutate(rank_int = ifelse(rank <= 1.49, 1,
ifelse(rank > 1.49 & rank <=2.49, 2,
ifelse(rank > 2.49 & rank <=3.49, 3,
ifelse(rank >3.49 & rank <=4.49, 4,
ifelse(rank >4.49 & rank <=5.49, 5,
ifelse(rank > 5.49 & rank <=6.49, 6,
ifelse(rank >6.49 & rank <=7.49, 7,
ifelse(rank>7.49 & rank <=8.49, 8,
ifelse(rank>8.49 & rank <=9.49,9,
ifelse(rank>9.49 & rank <=10.49, 10,
ifelse(rank>10.49 & rank <=11.49, 11,
ifelse(rank >11.49 & rank <=12.49, 12,
ifelse(rank >12.49 & rank <= 13.49, 13,
ifelse(rank >13.49 & rank <=14.49, 14, 15)))))))))))))))
## Verify Portfolio Effect ##
## group by unique ID and species to calculate the mean and variance of each species
portfolio_effect <- klee_long %>%
filter(!is.na(SPECIES), !is.na(Pin_Hits)) %>% #filter out any NA values
filter(Pin_Hits > 0) %>% #filter out abundances of 0
group_by(Unique_ID, SPECIES, TREATMENT) %>% #group by unique_ID & species
summarise(variance = var(Pin_Hits, na.rm = TRUE), meanhits = mean(Pin_Hits)) %>% #calculate mean & variance
mutate(logvar = log(variance), logmean = log(meanhits)) #log transform mean and variance
## remove log values less than 0
#linear model doesn't seem to work with NA and 0 values
portfolio <- portfolio_effect %>%
filter(logvar > 0, logmean > 0)
#run a linear model to calculate the slope
taylor <- lm(logvar~ logmean, data = portfolio)
summary(taylor)
#check that slope is between 1-2
## slope is 1.90052
## plot log variance and log mean
ggplot(portfolio, aes(x=logmean, y= logvar)) +
geom_point() +
geom_smooth(method = "lm")+
geom_abline(slope = 1, intercept = 0) +
theme_bw()
View(varian)
View(variance)
View(pinhits)
meanvar6 <- left_join(variance, pinhits, by = c("TREATMENT", "Unique_ID"))
meanvar18 <- left_join(variance, pinhits, by = c("TREATMENT", "Unique_ID"))
View(meanvar6)
meanvar6 <- meanvar18 %>%
group_by(TREATMENT) %>%
summarize(meanvar = mean(variance),
SEvar = calcSE(variance),
meanbio = mean(pinhits),
SEbio = mean(pinhits))
ggplot(meanvar6, aes(x=log(meanbio), y= log(meanvar))) +
geom_point() +
geom_smooth(method = "lm")+
geom_abline(slope = 1, intercept = 0) +
theme_bw()
ggplot(meanvar6, aes(x=log(meanbio), y= log(meanvar), color = TREATMENT)) +
geom_point() +
geom_smooth(method = "lm")+
geom_abline(slope = 1, intercept = 0) +
theme_bw()
View(meanvar18)
ggplot(meanvar6, aes(x=log(pinhits), y= log(variance), color = TREATMENT)) +
geom_point() +
geom_smooth(method = "lm")+
geom_abline(slope = 1, intercept = 0) +
theme_bw()
ggplot(meanvar18, aes(x=log(meanbio), y= log(meanvar))) +
geom_point() +
geom_smooth(method = "lm") +
geom_abline(slope = 1, intercept = 0) +
theme_bw()
ggplot(meanvar18, aes(x=log(pinhits), y= log(variance))) +
geom_point() +
geom_smooth(method = "lm") +
geom_abline(slope = 1, intercept = 0) +
theme_bw()
ggplot(meanvar18, aes(x=log(pinhits), y= log(variance), color = TREATMENT)) +
geom_point() +
geom_smooth(method = "lm") +
geom_abline(slope = 1, intercept = 0) +
theme_bw()
ggplot(meanvar18, aes(x=log(pinhits), y= log(variance), shape = TREATMENT)) +
geom_point() +
geom_smooth(method = "lm") +
geom_abline(slope = 1, intercept = 0) +
theme_bw()
ggplot(meanvar18, aes(x=log(pinhits), y= log(variance), color = TREATMENT)) +
geom_point() +
geom_smooth(method = "lm") +
geom_abline(slope = 1, intercept = 0) +
theme_bw()
ggplot(meanvar18, aes(x=log(pinhits), y= log(variance))) +
geom_point() +
geom_smooth(method = "lm") +
geom_abline(slope = 1, intercept = 0) +
theme_bw()
